<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ASCII Phoenix — Firebirth (Canvas)</title>
<style>
  :root {
    --bg: #0a0a0f;
    --fg: #e6e6f0;
  }
  * { box-sizing: border-box; }
  html, body {
    margin: 0;
    height: 100%;
    background: radial-gradient(1200px 800px at 50% 80%, #120f1a 0%, #0a0a0f 55%, #050509 100%);
    color: var(--fg);
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    overflow: hidden;
  }
  #wrap { position: fixed; inset: 0; display: grid; grid-template-rows: auto 1fr; }
  header {
    padding: 10px 14px;
    display: flex;
    gap: 14px;
    align-items: center;
    background: linear-gradient(to bottom, rgba(255,255,255,0.04), rgba(0,0,0,0));
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
    z-index: 2;
  }
  header h1 { margin: 0; font-size: 14px; font-weight: 600; letter-spacing: .08em; text-transform: uppercase; opacity: .8; }
  .controls { margin-left: auto; display: flex; gap: 8px; align-items: center; font-size: 12px; opacity: .9; }
  .controls label { display: inline-flex; gap: 6px; align-items: center; }
  .controls input[type=range] { width: 120px; }
  .btn { border: 1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.05); color: var(--fg);
    padding: 6px 10px; border-radius: 8px; cursor: pointer; font-size: 12px; }
  .btn:active { transform: translateY(1px); }
  #c { width: 100vw; height: calc(100vh - 48px); display: block; }
  footer { position: fixed; right: 10px; bottom: 8px; font-size: 11px; opacity: .6; }
</style>
</head>
<body>
<div id="wrap">
  <header>
    <h1>ASCII Phoenix — Firebirth</h1>
    <div class="controls">
      <label>Скорость <input id="speed" type="range" min="0.2" max="2.5" step="0.05" value="1.0"/></label>
      <label>Плотность <input id="density" type="range" min="6" max="16" step="1" value="10"/></label>
      <label>Цикл цвета <input id="hueshift" type="range" min="0" max="360" step="1" value="0"/></label>
      <button id="toggle" class="btn">Пауза</button>
    </div>
  </header>
  <canvas id="c"></canvas>
</div>
<footer>Зацикленная анимация рождения феникса из огня в ASCII на Canvas. ©</footer>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const speedEl = document.getElementById('speed');
  const densEl = document.getElementById('density');
  const hueEl = document.getElementById('hueshift');
  const toggleBtn = document.getElementById('toggle');
  let paused = false;

  const RAMP = ' .,:;i1tfLC08@#'; // ASCII символы
  let charW = 10, charH = 14, cols = 0, rows = 0;
  let t0 = performance.now();
  let loopLen = 9000;
  let baseHue = 18, hueShift = 0, speedMul = 1.0;

  let field, nextField, phoenixMask, phoenixDetailMask;
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

  function resize() {
    canvas.width = Math.floor(window.innerWidth * DPR);
    canvas.height = Math.floor((window.innerHeight - 48) * DPR);
    charW = Math.max(6, +densEl.value) * DPR;
    charH = Math.floor(charW * 1.35);
    cols = Math.floor(canvas.width / charW);
    rows = Math.floor(canvas.height / charH);
    field = new Float32Array(cols * rows).fill(0);
    nextField = new Float32Array(cols * rows).fill(0);
    phoenixMask = new Float32Array(cols * rows).fill(0);
    phoenixDetailMask = new Float32Array(cols * rows).fill(0);
    buildPhoenixMask();
  }
  function idx(x,y){ return y*cols + x; }
  function hash(x, y) {
    let n = x * 374761393 + y * 668265263;
    n = (n ^ (n >> 13)) * 1274126177;
    return ((n ^ (n >> 16)) >>> 0) / 4294967295;
  }
  function smoothNoise(x, y) {
    const xi = Math.floor(x), yi = Math.floor(y);
    const xf = x - xi, yf = y - yi;
    const n00 = hash(xi, yi), n10 = hash(xi+1, yi);
    const n01 = hash(xi, yi+1), n11 = hash(xi+1, yi+1);
    const sx = xf*xf*(3-2*xf), sy = yf*yf*(3-2*yf);
    const nx0 = n00*(1-sx) + n10*sx;
    const nx1 = n01*(1-sx) + n11*sx;
    return nx0*(1-sy) + nx1*sy;
  }
  function fbm(x, y, oct=4) {
    let a=0, amp=0.5, freq=1.0;
    for (let i=0;i<oct;i++) {
      a += smoothNoise(x*freq, y*freq) * amp;
      freq *= 2.01; amp *= 0.55;
    }
    return a;
  }
  function buildPhoenixMask() {
    phoenixMask.fill(0);
    phoenixDetailMask.fill(0);
    const cx = cols/2, cy = rows*0.62;
    const scale = Math.min(cols, rows) * 0.45;
    for (let y=0; y<rows; y++) {
      for (let x=0; x<cols; x++) {
        const nx = (x - cx) / scale;
        const ny = (y - cy) / scale;
        const r = Math.hypot(nx*0.9, ny*1.2);
        const body = Math.max(0, 1 - r*r*1.8 - (ny*0.6+0.15));
        const wingL = Math.max(0, 1 - (Math.hypot((nx+0.9)*1.1, (ny+0.05)*1.9)*1.6));
        const wingR = Math.max(0, 1 - (Math.hypot((nx-0.9)*1.1, (ny+0.05)*1.9)*1.6));
        const tail = Math.max(0, 1 - Math.hypot(nx*0.7, (ny-0.7)*2.2)*1.8);
        const head = Math.max(0, 1 - Math.hypot((nx)*2.0, (ny+0.25)*3.4)*2.2);
        const beak = Math.max(0, 1 - Math.hypot((nx-0.18)*8.5, (ny+0.23)*10.0)*1.3);
        let m = Math.max(body*1.05, wingL*0.95, wingR*0.95, tail*0.8, head*1.1, beak*0.8);
        m = Math.min(1, Math.max(0, m));
        const d = Math.pow(fbm(nx*3+5.4, ny*3-2.7, 3), 1.6);
        const feather = m * (0.35 + 0.65*d);
        phoenixMask[idx(x,y)] = m;
        phoenixDetailMask[idx(x,y)] = feather;
      }
    }
  }
  
  // New function to create flame tongue effect
  function createFlameEffect(time) {
    const t = time * 0.001;
    const flameMask = new Float32Array(cols * rows).fill(0);
    const cx = cols/2, cy = rows*0.75; // Flame origin at bottom center
    
    for (let y=0; y<rows; y++) {
      for (let x=0; x<cols; x++) {
        // Distance from bottom center
        const dx = x - cx;
        const dy = y - cy;
        const distance = Math.sqrt(dx*dx + dy*dy);
        
        // Create multiple flame tongues with random offsets
        let flameIntensity = 0;
        
        // Main central flame
        const angle = Math.atan2(dy, dx);
        const wave = Math.sin(angle * 3 + t * 2) * 0.3;
        const flameShape = Math.max(0, 1 - (distance / (rows * 0.4)) + wave);
        flameIntensity = Math.max(flameIntensity, flameShape * 0.8);
        
        // Secondary flames
        for (let i = 0; i < 5; i++) {
          const offsetX = Math.sin(t * 0.5 + i) * 20;
          const offsetY = Math.cos(t * 0.7 + i) * 10;
          const dx2 = x - (cx + offsetX);
          const dy2 = y - (cy + offsetY);
          const dist2 = Math.sqrt(dx2*dx2 + dy2*dy2);
          const angle2 = Math.atan2(dy2, dx2);
          const wave2 = Math.sin(angle2 * 2 + t * 3 + i) * 0.2;
          const flameShape2 = Math.max(0, 1 - (dist2 / (rows * 0.3)) + wave2);
          flameIntensity = Math.max(flameIntensity, flameShape2 * 0.6);
        }
        
        flameMask[idx(x,y)] = Math.min(1, flameIntensity);
      }
    }
    return flameMask;
  }
  
  // Function to interpolate between two colors
  function interpolateColor(color1, color2, factor) {
    const result = [];
    for (let i = 0; i < 3; i++) {
      result.push(Math.round(color1[i] + (color2[i] - color1[i]) * factor));
    }
    return result;
  }
  
  // Function to get a random flame color from our extended palette
  function getRandomFlameColor() {
    // Extended flame color palette with more vibrant colors
    const flameColors = [
      [255, 255, 204],  // Light Yellow (#FFFFCC)
      [255, 242, 153],  // Yellow (#FFF299)
      [255, 229, 102],  // Golden Yellow (#FFE566)
      [255, 215, 0],    // Yellow (#FFD700)
      [255, 204, 0],    // Yellow-Orange (#FFCC00)
      [255, 191, 0],    // Golden (#FFBF00)
      [255, 178, 0],    // Orange-Yellow (#FFB200)
      [255, 165, 0],    // Orange (#FFA500)
      [255, 153, 0],    // Slightly Darker Orange (#FF9900)
      [255, 140, 0],    // Dark Orange (#FF8C00)
      [255, 128, 0],    // Bright Orange (#FF8000)
      [255, 115, 0],    // Deep Orange (#FF7300)
      [255, 102, 0],    // Vibrant Orange (#FF6600)
      [255, 90, 0],     // Bright Red-Orange (#FF5A00)
      [255, 77, 0],     // Intense Orange (#FF4D00)
      [255, 64, 0]      // Deep Red-Orange (#FF4000)
    ];
    
    // Return a random color from our palette
    const randomIndex = Math.floor(Math.random() * flameColors.length);
    return flameColors[randomIndex];
  }
  
  // Function to get flame color based on value (intensity) with smoother transitions
  function getFlameColorByValue(v) {
    // Extended flame color palette with more vibrant colors
    const flameColors = [
      [255, 255, 204],  // Light Yellow (#FFFFCC)
      [255, 242, 153],  // Yellow (#FFF299)
      [255, 229, 102],  // Golden Yellow (#FFE566)
      [255, 215, 0],    // Yellow (#FFD700)
      [255, 204, 0],    // Yellow-Orange (#FFCC00)
      [255, 191, 0],    // Golden (#FFBF00)
      [255, 178, 0],    // Orange-Yellow (#FFB200)
      [255, 165, 0],    // Orange (#FFA500)
      [255, 153, 0],    // Slightly Darker Orange (#FF9900)
      [255, 140, 0],    // Dark Orange (#FF8C00)
      [255, 128, 0],    // Bright Orange (#FF8000)
      [255, 115, 0],    // Deep Orange (#FF7300)
      [255, 102, 0],    // Vibrant Orange (#FF6600)
      [255, 90, 0],     // Bright Red-Orange (#FF5A00)
      [255, 77, 0],     // Intense Orange (#FF4D00)
      [255, 64, 0]      // Deep Red-Orange (#FF4000)
    ];
    
    // Map the value (0-1) to a position in our extended flame gradient
    const index = Math.min(flameColors.length - 1, Math.floor(v * flameColors.length));
    return flameColors[index];
  }
  
  function draw(time) {
    if (paused) { requestAnimationFrame(draw); return; }
    const t = (time - t0) * speedMul;
    const phase = (t % loopLen) / loopLen;
    
    // Create flame effect instead of phoenix
    const flameMask = createFlameEffect(t);
    
    // Apply noise to flame for more realistic movement
    for (let x=0; x<cols; x++) {
      const n = fbm(x*0.07, t*0.0009, 3);
      field[idx(x, rows-1)] = 0.6 + 0.4*n;
    }
    for (let y=0; y<rows-1; y++) {
      for (let x=0; x<cols; x++) {
        const j = Math.floor((smoothNoise(x*0.17, (t*0.001 + y*0.05))*2-1)*2);
        const sx = Math.min(cols-1, Math.max(0, x + j));
        const sy = Math.min(rows-1, y+1);
        const v = field[idx(sx, sy)];
        const l = field[idx(Math.max(0,x-1), sy)];
        const r = field[idx(Math.min(cols-1,x+1), sy)];
        nextField[idx(x,y)] = (v*2 + l + r) * 0.25 * 0.98;
      }
    }
    [field, nextField] = [nextField, field];
    
    // Apply flame mask to field
    for (let y=0; y<rows; y++) {
      for (let x=0; x<cols; x++) {
        const flameIntensity = flameMask[idx(x,y)];
        field[idx(x,y)] = Math.min(1, field[idx(x,y)] + flameIntensity * 0.7);
      }
    }
    
    ctx.clearRect(0,0,canvas.width, canvas.height);
    ctx.save();
    ctx.translate((canvas.width - cols*charW)/2, (canvas.height - rows*charH)/2);
    ctx.font = `${Math.floor(charH*0.95)}px monospace`;
    ctx.textBaseline = 'top';
    for (let y=0; y<rows; y++) {
      for (let x=0; x<cols; x++) {
        const v = field[idx(x,y)];
        const rampIndex = Math.min(RAMP.length-1, Math.max(0, Math.floor(v * (RAMP.length-1))));
        const ch = RAMP[rampIndex];
        if (ch === ' ') continue;
        
        // Use flame colors instead of the original HSV-based coloring
        const [r, g, b] = getFlameColorByValue(v);
        ctx.fillStyle = `rgba(${r},${g},${b},${0.85})`;
        ctx.fillText(ch, x*charW, y*charH);
      }
    }
    ctx.restore();
    requestAnimationFrame(draw);
  }
  speedEl.addEventListener('input', () => { speedMul = +speedEl.value; });
  densEl.addEventListener('input', resize);
  hueEl.addEventListener('input', () => { hueShift = +hueEl.value; });
  toggleBtn.addEventListener('click', () => { paused = !paused; toggleBtn.textContent = paused ? 'Пуск' : 'Пауза'; });
  window.addEventListener('resize', resize, {passive:true});
  resize();
  requestAnimationFrame(draw);
})();
</script>
</body>
</html>
