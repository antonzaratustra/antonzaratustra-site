<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ASCII Phoenix — Firebirth (Canvas)</title>
<style>
  :root {
    --bg: #0a0a0f;
    --fg: #e6e6f0;
  }
  * { box-sizing: border-box; }
  html, body {
    margin: 0;
    height: 100%;
    background: radial-gradient(1200px 800px at 50% 80%, #120f1a 0%, #0a0a0f 55%, #050509 100%);
    color: var(--fg);
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    overflow: hidden;
  }
  #wrap { position: fixed; inset: 0; display: grid; grid-template-rows: auto 1fr; }
  header {
    padding: 10px 14px;
    display: flex;
    gap: 14px;
    align-items: center;
    background: linear-gradient(to bottom, rgba(255,255,255,0.04), rgba(0,0,0,0));
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
    z-index: 2;
  }
  header h1 { margin: 0; font-size: 14px; font-weight: 600; letter-spacing: .08em; text-transform: uppercase; opacity: .8; }
  .controls { margin-left: auto; display: flex; gap: 8px; align-items: center; font-size: 12px; opacity: .9; }
  .controls label { display: inline-flex; gap: 6px; align-items: center; }
  .controls input[type=range] { width: 120px; }
  .btn { border: 1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.05); color: var(--fg);
    padding: 6px 10px; border-radius: 8px; cursor: pointer; font-size: 12px; }
  .btn:active { transform: translateY(1px); }
  #c { width: 100vw; height: calc(100vh - 48px); display: block; }
  footer { position: fixed; right: 10px; bottom: 8px; font-size: 11px; opacity: .6; }
</style>
</head>
<body>
<div id="wrap">
  <header>
    <h1>ASCII Phoenix — Firebirth</h1>
    <div class="controls">
      <label>Скорость <input id="speed" type="range" min="0.2" max="2.5" step="0.05" value="1.0"/></label>
      <label>Плотность <input id="density" type="range" min="6" max="16" step="1" value="10"/></label>
      <label>Цикл цвета <input id="hueshift" type="range" min="0" max="360" step="1" value="0"/></label>
      <button id="toggle" class="btn">Пауза</button>
    </div>
  </header>
  <canvas id="c"></canvas>
</div>
<footer>Зацикленная анимация рождения феникса из огня в ASCII на Canvas. ©</footer>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const speedEl = document.getElementById('speed');
  const densEl = document.getElementById('density');
  const hueEl = document.getElementById('hueshift');
  const toggleBtn = document.getElementById('toggle');
  let paused = false;

  const RAMP = ' .,:;i1tfLC08@#'; // ASCII символы
  let charW = 10, charH = 14, cols = 0, rows = 0;
  let t0 = performance.now();
  let loopLen = 9000;
  let baseHue = 18, hueShift = 0, speedMul = 1.0;

  let field, nextField, phoenixMask, phoenixDetailMask;
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

  function resize() {
    canvas.width = Math.floor(window.innerWidth * DPR);
    canvas.height = Math.floor((window.innerHeight - 48) * DPR);
    charW = Math.max(6, +densEl.value) * DPR;
    charH = Math.floor(charW * 1.35);
    cols = Math.floor(canvas.width / charW);
    rows = Math.floor(canvas.height / charH);
    field = new Float32Array(cols * rows).fill(0);
    nextField = new Float32Array(cols * rows).fill(0);
    phoenixMask = new Float32Array(cols * rows).fill(0);
    phoenixDetailMask = new Float32Array(cols * rows).fill(0);
    buildPhoenixMask();
  }
  function idx(x,y){ return y*cols + x; }
  function hash(x, y) {
    let n = x * 374761393 + y * 668265263;
    n = (n ^ (n >> 13)) * 1274126177;
    return ((n ^ (n >> 16)) >>> 0) / 4294967295;
  }
  function smoothNoise(x, y) {
    const xi = Math.floor(x), yi = Math.floor(y);
    const xf = x - xi, yf = y - yi;
    const n00 = hash(xi, yi), n10 = hash(xi+1, yi);
    const n01 = hash(xi, yi+1), n11 = hash(xi+1, yi+1);
    const sx = xf*xf*(3-2*xf), sy = yf*yf*(3-2*yf);
    const nx0 = n00*(1-sx) + n10*sx;
    const nx1 = n01*(1-sx) + n11*sx;
    return nx0*(1-sy) + nx1*sy;
  }
  function fbm(x, y, oct=4) {
    let a=0, amp=0.5, freq=1.0;
    for (let i=0;i<oct;i++) {
      a += smoothNoise(x*freq, y*freq) * amp;
      freq *= 2.01; amp *= 0.55;
    }
    return a;
  }
  function buildPhoenixMask() {
    phoenixMask.fill(0);
    phoenixDetailMask.fill(0);
    const cx = cols/2, cy = rows*0.62;
    const scale = Math.min(cols, rows) * 0.45;
    for (let y=0; y<rows; y++) {
      for (let x=0; x<cols; x++) {
        const nx = (x - cx) / scale;
        const ny = (y - cy) / scale;
        const r = Math.hypot(nx*0.9, ny*1.2);
        const body = Math.max(0, 1 - r*r*1.8 - (ny*0.6+0.15));
        const wingL = Math.max(0, 1 - (Math.hypot((nx+0.9)*1.1, (ny+0.05)*1.9)*1.6));
        const wingR = Math.max(0, 1 - (Math.hypot((nx-0.9)*1.1, (ny+0.05)*1.9)*1.6));
        const tail = Math.max(0, 1 - Math.hypot(nx*0.7, (ny-0.7)*2.2)*1.8);
        const head = Math.max(0, 1 - Math.hypot((nx)*2.0, (ny+0.25)*3.4)*2.2);
        const beak = Math.max(0, 1 - Math.hypot((nx-0.18)*8.5, (ny+0.23)*10.0)*1.3);
        let m = Math.max(body*1.05, wingL*0.95, wingR*0.95, tail*0.8, head*1.1, beak*0.8);
        m = Math.min(1, Math.max(0, m));
        const d = Math.pow(fbm(nx*3+5.4, ny*3-2.7, 3), 1.6);
        const feather = m * (0.35 + 0.65*d);
        phoenixMask[idx(x,y)] = m;
        phoenixDetailMask[idx(x,y)] = feather;
      }
    }
  }
  function hsvToRgb(h, s, v) {
    h = (h%360+360)%360;
    const c = v * s, x = c * (1 - Math.abs(((h/60)%2)-1)), m = v - c;
    let r=0,g=0,b=0;
    if (0<=h && h<60){ r=c; g=x; }
    else if (60<=h && h<120){ r=x; g=c; }
    else if (120<=h && h<180){ g=c; b=x; }
    else if (180<=h && h<240){ g=x; b=c; }
    else if (240<=h && h<300){ r=x; b=c; }
    else { r=c; b=x; }
    return [(r+m)*255, (g+m)*255, (b+m)*255];
  }
  function draw(time) {
    if (paused) { requestAnimationFrame(draw); return; }
    const t = (time - t0) * speedMul;
    const phase = (t % loopLen) / loopLen;
    for (let x=0; x<cols; x++) {
      const n = fbm(x*0.07, t*0.0009, 3);
      field[idx(x, rows-1)] = 0.6 + 0.4*n;
    }
    for (let y=0; y<rows-1; y++) {
      for (let x=0; x<cols; x++) {
        const j = Math.floor((smoothNoise(x*0.17, (t*0.001 + y*0.05))*2-1)*2);
        const sx = Math.min(cols-1, Math.max(0, x + j));
        const sy = Math.min(rows-1, y+1);
        const v = field[idx(sx, sy)];
        const l = field[idx(Math.max(0,x-1), sy)];
        const r = field[idx(Math.min(cols-1,x+1), sy)];
        nextField[idx(x,y)] = (v*2 + l + r) * 0.25 * 0.98;
      }
    }
    [field, nextField] = [nextField, field];
    let birth=0, flap=0, dissolve=0;
    if (phase < 0.35) birth = phase/0.35;
    else if (phase < 0.65) birth = 1;
    else if (phase < 0.85) { birth = 1; flap = (phase-0.65)/0.20; }
    else { birth = 1; dissolve = (phase-0.85)/0.15; }
    for (let y=0; y<rows; y++) {
      for (let x=0; x<cols; x++) {
        const m = phoenixMask[idx(x,y)];
        if (m <= 0.001) continue;
        const fdet = phoenixDetailMask[idx(x,y)];
        const wingWave = Math.sin((y*0.25 + t*0.006) + (x-cols/2)*0.02) * 0.5 + 0.5;
        const flapAmp = 0.25 + 0.55*flap;
        const energy = (0.35 + 0.65*fdet) * birth * (1.0 - dissolve*0.85);
        const extra = energy * (0.7 + 0.3*wingWave*flapAmp);
        field[idx(x,y)] = Math.min(1, field[idx(x,y)] + extra*0.7);
      }
    }
    if (dissolve > 0) {
      const k = 0.5 + 0.5*dissolve;
      for (let y=0; y<rows; y++) {
        const cool = k * (y/rows) * 0.35;
        for (let x=0; x<cols; x++) {
          field[idx(x,y)] = Math.max(0, field[idx(x,y)] - cool);
        }
      }
    }
    ctx.clearRect(0,0,canvas.width, canvas.height);
    ctx.save();
    ctx.translate((canvas.width - cols*charW)/2, (canvas.height - rows*charH)/2);
    ctx.font = `${Math.floor(charH*0.95)}px monospace`;
    ctx.textBaseline = 'top';
    const hueBase = baseHue + hueShift + (Math.sin(t*0.0003)*30);
    for (let y=0; y<rows; y++) {
      for (let x=0; x<cols; x++) {
        const v = field[idx(x,y)];
        const rampIndex = Math.min(RAMP.length-1, Math.max(0, Math.floor(v * (RAMP.length-1))));
        const ch = RAMP[rampIndex];
        if (ch === ' ') continue;
        const h = hueBase + v*40;
        const s = 0.75 - v*0.25;
        const val = 0.3 + v*0.7;
        const [r,g,b] = hsvToRgb(h, s, val);
        ctx.fillStyle = `rgba(${r|0},${g|0},${b|0},${0.85})`;
        ctx.fillText(ch, x*charW, y*charH);
      }
    }
    ctx.restore();
    requestAnimationFrame(draw);
  }
  speedEl.addEventListener('input', () => { speedMul = +speedEl.value; });
  densEl.addEventListener('input', resize);
  hueEl.addEventListener('input', () => { hueShift = +hueEl.value; });
  toggleBtn.addEventListener('click', () => { paused = !paused; toggleBtn.textContent = paused ? 'Пуск' : 'Пауза'; });
  window.addEventListener('resize', resize, {passive:true});
  resize();
  requestAnimationFrame(draw);
})();
</script>
</body>
</html>
